# HashMap

## 

哈希表基于Map接口进行实现，该实现提供了map的所有操作，并且允许`null`值和`null`键。（HashMap类和HashTable类大致相同，区别在于它是非同步和允许`null`键的）。HashMap不保证元素顺序，也不能保证顺序在一段时间内不变。

## 性能

HashMap的哈希函数将元素正确的分散在存储桶（buckets）中，因此为基础操作（get/put）提供了常量时间的性能。

HashMap遍历的时间和容量（capacity）成正比，而不是键值对的总量（size）。如果很在意迭代的性能，在初始化该类时，不要将初始容量设置的过高，或者将负载因子设置得过低。

初始容量（capacity）和负载因子(load factor)是影响HashMap的性能的两个因素。

- 容量
  - 哈希表中的桶（buckets）的数量
- 负载因子
  - 衡量HashMap在自动扩容前所允许到达多满的指标。

当哈希表中的键值对数量超过当前容量和负载因子的乘积时，哈希表将会重新进行哈希操作，使得哈希表的容量扩展至大约两倍。

## 负载因子

一般情况下，默认的负载因子为`0.75`为时间和空间成本之间提供一个很好的权衡。
越高的数值提供较高的弓箭使用率，但是会增加查找成本。

当 `初始化容量 > 键值对的最大值 / 负载因子，`时，哈希表不会发成重新哈希操作。


注意点：如果有很多keys拥有相同的哈希码，那么会降低哈希表的性能；当key是Comparable时，HashMap可以通过比较key的顺序，来改善该种情况（红黑树的情况下）。

## 线程安全性

HashMap时非同步的，当有多个线程同时访问时，如果有至少一个线程修改了哈希表的数据结构，那么一定要在外部对其进行同步（修改结构指的是增加或删除一个键值对，如果只是改变键对应的值，并不算修改结构）。


Map m = Collections.synchronizedMap(new HashMap(...));

## 

HashMap